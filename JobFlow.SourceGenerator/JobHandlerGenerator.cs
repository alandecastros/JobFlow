using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace JobFlow.SourceGenerator
{
    [Generator]
    public class JobHandlerGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var handlerProvider = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsHandlerClass(s),
                    transform: static (ctx, _) => GetHandlerInfo(ctx))
                .Where(static m => m is not null);

            context.RegisterSourceOutput(handlerProvider.Collect(), Execute);
        }

        private static bool IsHandlerClass(SyntaxNode node)
        {
            return node is ClassDeclarationSyntax classDecl && 
                   classDecl.BaseList?.Types.Any(t => 
                       t.ToString().Contains("IJobHandler")) == true;
        }

        private static HandlerInfo? GetHandlerInfo(GeneratorSyntaxContext context)
        {
            var classDecl = (ClassDeclarationSyntax)context.Node;
            var symbol = context.SemanticModel.GetDeclaredSymbol(classDecl);
            
            if (symbol == null) return null;

            foreach (var interfaceSymbol in symbol.AllInterfaces)
            {
                if (interfaceSymbol.Name == "IJobHandler")
                {
                    var typeArgs = interfaceSymbol.TypeArguments;
                    
                    if (typeArgs.Length == 1)
                    {
                        return new HandlerInfo
                        {
                            JobType = typeArgs[0].ToDisplayString(),
                            JobTypeName = typeArgs[0].Name,
                            ReturnType = null,
                            HandlerType = symbol.ToDisplayString(),
                            IsVoid = true
                        };
                    }
                    else if (typeArgs.Length == 2)
                    {
                        return new HandlerInfo
                        {
                            JobType = typeArgs[0].ToDisplayString(),
                            JobTypeName = typeArgs[0].Name,
                            ReturnType = typeArgs[1].ToDisplayString(),
                            HandlerType = symbol.ToDisplayString(),
                            IsVoid = false
                        };
                    }
                }
            }

            return null;
        }

        private static void Execute(SourceProductionContext context, ImmutableArray<HandlerInfo?> handlers)
        {
            var validHandlers = handlers.Where(h => h != null).Cast<HandlerInfo>().ToList();
            
            if (!validHandlers.Any())
                return;

            var sourceCode = GenerateJobHandlerCaller(validHandlers);
            context.AddSource("GeneratedJobHandlerCaller.g.cs", sourceCode);
        }

        private static string GenerateJobHandlerCaller(List<HandlerInfo> handlers)
        {
            var sb = new StringBuilder();
            
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("// Este arquivo foi gerado automaticamente pelo JobHandlerGenerator");
            sb.AppendLine("// N√ÉO EDITE ESTE ARQUIVO MANUALMENTE!");
            sb.AppendLine();
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Threading;");
            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine("using JobFlow.Core.Abstractions;");
            sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            sb.AppendLine();
            sb.AppendLine("namespace JobFlow.Core");
            sb.AppendLine("{");
            
            sb.AppendLine("    public partial class GeneratedJobHandlerCaller : IJobHandlerCaller");
            sb.AppendLine("    {");
            sb.AppendLine("        private readonly IServiceProvider _serviceProvider;");
            sb.AppendLine();
            sb.AppendLine("        public GeneratedJobHandlerCaller(IServiceProvider serviceProvider)");
            sb.AppendLine("        {");
            sb.AppendLine("            _serviceProvider = serviceProvider;");
            sb.AppendLine("        }");
            sb.AppendLine();
            
            sb.AppendLine("        public async Task<object?> CallHandler(");
            sb.AppendLine("            string jobId,");
            sb.AppendLine("            Type messageType,");
            sb.AppendLine("            object? payload,");
            sb.AppendLine("            CancellationToken cancellationToken)");
            sb.AppendLine("        {");
            sb.AppendLine("            using var scope = _serviceProvider.CreateScope();");
            sb.AppendLine();
            sb.AppendLine("            return messageType.FullName switch");
            sb.AppendLine("            {");
            
            foreach (var handler in handlers)
            {
                sb.AppendLine($"                \"{handler.JobType}\" => ");
                sb.AppendLine($"                    await Handle{handler.JobTypeName}(scope.ServiceProvider, jobId, ({handler.JobType})payload!, cancellationToken),");
                sb.AppendLine();
            }
            
            sb.AppendLine("                _ => throw new JobPayloadTypeNotFoundException(\"Generated\", messageType.FullName ?? \"Unknown\")");
            sb.AppendLine("            };");
            sb.AppendLine("        }");
            sb.AppendLine();
            
            foreach (var handler in handlers)
            {
                GenerateHandlerMethod(sb, handler);
            }
            
            sb.AppendLine("    }");
            sb.AppendLine("}");
            
            return sb.ToString();
        }

        private static void GenerateHandlerMethod(StringBuilder sb, HandlerInfo handler)
        {
            sb.AppendLine($"        private static async Task<object?> Handle{handler.JobTypeName}(");
            sb.AppendLine("            IServiceProvider serviceProvider,");
            sb.AppendLine("            string jobId,");
            sb.AppendLine($"            {handler.JobType} payload,");
            sb.AppendLine("            CancellationToken cancellationToken)");
            sb.AppendLine("        {");
            
            if (handler.IsVoid)
            {
                sb.AppendLine($"            var handler = serviceProvider.GetRequiredService<IJobHandler<{handler.JobType}>>();");
                sb.AppendLine("            await handler.HandleJobAsync(jobId, payload, cancellationToken);");
                sb.AppendLine("            return null;");
            }
            else
            {
                sb.AppendLine($"            var handler = serviceProvider.GetRequiredService<IJobHandler<{handler.JobType}, {handler.ReturnType}>>();");
                sb.AppendLine("            var result = await handler.HandleJobAsync(jobId, payload, cancellationToken);");
                sb.AppendLine("            return result;");
            }
            
            sb.AppendLine("        }");
            sb.AppendLine();
        }
    }

    public class HandlerInfo
    {
        public string JobType { get; set; } = string.Empty;
        public string JobTypeName { get; set; } = string.Empty;
        public string? ReturnType { get; set; }
        public string HandlerType { get; set; } = string.Empty;
        public bool IsVoid { get; set; }
    }
}